# -*- coding: utf-8 -*-
"""PZO_cz1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JbrvlaNacm3oZNnzQdVxGNRMy0NdJWuV

# Algorytmy i programowanie

## Progamowanie zorientowane obiektowo (PZO), część 1

Wprowadzenie do PZO. 
Dobrze jest znaleźć jakąś ciekawą książkę (kurs on-line) opisującą PZO dla języka Python (jP), która skupi się nieco na teorii i poczytać. Tutaj będziemy zajmować się PZO bezpośrednio.

> **Uwaga 1** treść z gwiazdką `*` jest ponadpodstawowa
"""



"""### Obiekt i jego klasa
**Klasa** - częściowa lub całkowita **definicja dla obiektów**. Definicja obejmuje dopuszczalny **stan obiektów** oraz ich **zachowania**. W jP klasę definiujemy za pomocą słowa `class`, po którym podajemy nazwę w konwencji [PascalCase](https://pl.wikipedia.org/wiki/PascalCase) (PEP8), a następnie mamy do wyboru - albo dajemy po prostu dwukropek, albo dajemy nawias, gdzie podajemy nazwę klasy nadrzędnej (o tym na kolejnej lekcji). Jeżeli budujemy klasę od zera to podajemy tam `object`. Poniższe definicje klasy `NazwaKlasy` są równoważne.
"""

class NazwaKlasy:
    """docstring"""
    pass


class NazwaKlasy(object):
    """docstring"""
    pass

"""# Studium przypadku 1 - Gruszka

Jak wyżej napisano - klasa definiuje stan i zachowania obiektów. Możemy sobie za jej pomocą opisać jakie dany obiekt ma własności oraz co z nim można zrobić. Typowym przykładem obiektu może być cokolwiek ;) np: gruszka. Gruszkę taką możemy opisać mówiąc o jej odmianie, kolorze (który wiąże się z odmianą), wadze, wielkości (ta wiąże się z wagą), smaku (słodki, kwaśny...). Napiszmy klasę `Gruszka`, żeby zobrazować ideę
"""

class Gruszka:
    '''Obiekt Gruszka opisuje nam wlasnosci gruszek.
    
    Dzieki obiektom Gruszka można skatalogować gruszki z naszego ogrodu.
    Aby poprawnie opisać gruszki, trzeba podać ich odmianę (str),
    wagę (num) oraz smak (str).

    Args:
        odmiana (str): trzyma odmiane owocu 
        waga (num): trzyma wage gruszek
        smak (str): opisuje smak gruszek (slodki, kwasny, itd.)

    Attributes:
        odmiana: tu przechowujemy informacje o odmianie 
        waga: tu przechowujemy informacje o wadze
        smak: tu przechowujemy informacje o smaku
    '''
    
    def __init__(self, odmiana, waga, smak):
        self.odmiana = odmiana
        self.waga = waga
        self.smak = smak
        
    def waga_plus_jeden(k):
        '''Funkcja 
        '''
        print(k.waga + 1)

    def waga_razy_100(sobota):
        print("TEST:  " + str(sobota.waga * 10))



"""W ten sposób zbudowaliśmy klasę opisującą gruszki. 

> Zanim krok dalej krótkie wtrącenie o budowaniu dokumentacji. W ogólności jak budować dokumentację jest opisane w *PEP 257*, niemniej jednak istnieją 3 najbardziej popularne konwencje budowania dokumentacji do obiektów w jP, style Pydoc/Sphinx, Google, Numpy/Scipy i Epydoc. Ta powyższa to **styl Google**. Możecie dokładnie o niej poczytać tutaj: [styl dokumentacji Google](http://google.github.io/styleguide/pyguide.html). Zobacz też zadanie domowe *PD03X*.

W kolejnych lekcjach wprowadzę pozostałe.

Nie można nic ciekawego z tą klasą na razie zrobić, ale zbudowaliśmy klasę, będącą definicją **obiektu** który możemy stworzyć. Stwórzmy sobie taki obiekt
"""

gruszka1 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')
gruszka1.waga_razy_100()

"""Mamy obiekt `gruszka1`. Jeżeli potraktujem klasę jak wzorzec (pieczątkę), który należy wypełnić, to obiekt `gruszka1` będzie właśnie wypełnieniem takiego wzorca klasy `Gruszka`, ale **z konkretnymi wartościami (argumentami)** podanymi do parametrów formalnych klasy. W tym przypadku

    odmiana <- 'General Leclerc'
    waga <- 130
    smak <- 'kwaskowato-slodka'
    
Taką **skonkretyzowany wzorzec klasy** będziemy nazywać **instancją klasy** lub po prostu **instancją**. Instancja taka posiada swoje **atrybuty**: `odmiana`, `waga` i `smak`, które są w tym przypadku tożsame z **atrybutami klasy**. Możemy się do nich odwołać, tak jak do zwykłych zmiennych (bo też są zmiennymi) za pomocą *notacji z kropką*
"""

gruszka1.odmiana

print(type(gruszka1.odmiana))

"""Możemy z nimi robić to, co zazwyczaj można robić ze zmiennymi o danym typie. W szczególności przypisać do atrybutu zupełnie inny obiekt."""

print("*3:", gruszka1.odmiana * 3)
print("[8:]:", gruszka1.odmiana[8:])

gruszka1.odmiana = "Komisówka"
print('Nowy typ:', gruszka1.odmiana)

"""**Jeżeli czytacie ten dokument sami:** 
proszę zrobić zadanie domowe PD0301 (`is_aip_pd03.ipynb`).
"""

gruszka1.waga_plus_jeden()



"""### Ćwiczenie 1
Na bazie klasy `Gruszka` proszę stworzyć cztery proste klasy uwzględniając podane atrybuty.

1. klasa `Orzech`: odmiana (str), rozmiar (num), cena (num)
2. klasa `Motor`: marka (str), pojemnosc (num), KM (int)
3. klasa `Kot`: rasa (str), umaszczenie (str), imie (str)
4. klasa `Ksiazka`: tytul (str), autor (str), rok_wydania (int)
5. klasa `Kubek`: pojemność (num), materiał (str), kolor (str)
6. klasa `Obraz`: autor (str), technika (str), autor (str)

Podzielić powyższe klasy na studentów lub wymyslić inne dodatkowe.
"""

class Orzech:
    '''Obiekt Orzech opisuje nam wlasnosci gruszek.
    
    Dzieki obiektom Orzech można skatalogować gruszki z naszego ogrodu.
    Aby poprawnie opisać orzecj, trzeba podać ich odmianę (str),
    rozmiar (num) oraz cena (num).

    Args:
        odmiana (str): trzyma odmiane owocu 
        rozmiar (num): trzyma rozmiar orzechu
        cena (num): opisuje cene orzechu (slodki, kwasny, itd.)

    Attributes:
        odmiana: tu przechowujemy informacje o odmianie 
        rozmiar: tu przechowujemy informacje o wadze
        cena: tu przechowujemy informacje o smaku
    '''
    
    def __init__(self, odmiana, rozmiar, cena):
        self.odmiana = odmiana
        self.rozmiar = rozmiar
        self.cena = cena


    # setter
    def set_cena(k, value):
        '''Funkcja
        '''
        k.cena += value

    # getter
    def get_cena(k):
        return k.cena


orzech1 = Orzech('laskowy', 13, 50)
print(orzech1.cena)

print("cena: " + str(orzech1.get_cena()))

orzech1.set_cena(2)
print("nowa cena:: " + str(orzech1.cena))

print("cena: " + str(orzech1.get_cena()))

orzech1.odmiana = 'wloski'
print(orzech1.odmiana)


# klasa Motor: marka (str), pojemnosc (num), KM (int)
class Motor:
    '''Obiekt  opisuje nam wlasnosci motorów.
    
    Dzieki obiektom Motore można skatalogować typy motoru.
    Aby poprawnie opisać orzecj, trzeba podać ich marka (str),
    waga (num) oraz cena (num).

    Args:
        marka (str): trzyma odmiane owocu 
        waga (num): trzyma rozmiar orzechu
        cena (num): opisuje cene orzechu (slodki, kwasny, itd.)

    Attributes:
        marka: tu przechowujemy informacje o odmianie 
        waga: tu przechowujemy informacje o wadze
        cena: tu przechowujemy informacje o smaku
    '''
    
    def __init__(self, marka, waga, cena):
        self.marka = marka
        self.waga = waga
        self.cena = cena

    def set_cena(self, value):
        if isinstance(value, (int, float)):
            if value > 0:
                self.cena += value
            else:
                raise TypeError("CEna musi być większa od zera")
        else:
            raise TypeError("Cena powinna byc liczba INT lub FLOAT")


    def get_cena(self):
        return self.cena


    def __repr__(self):
        return '(String, Float, Float) (%s, %s, %s)' % (self.marka, self.waga, self.cena)

        # For call to str(). Prints readable form

    def __str__(self):
        return 'Ten motor %s ma wagę %s, i kosztuje %s' % (self.marka, self.waga, self.cena)



motor1 = Motor('KTM', 130, 500)


print("str::: motor1")
print(motor1)
print(repr(motor1))


print(motor1.cena)

print("get cena: " + str(motor1.get_cena()))

motor1.set_cena(50)
print("nowa cena motor:: " + str(motor1.cena))

print("get cena: " + str(motor1.get_cena()))


orzech2 = Orzech('polski', 20, 70)
print(orzech2.cena)

print(orzech2)


"""### `__init___`
Łatwo zauważyć, że to właśnie *funkcja specjalna* `__init__` służy do przechwytywania argumentów służących do instancjonowania klasy `Gruszka`. Takich funkcji specjalnych jest dużo, dwie inne poznacie w pracy domowej, resztę zostawimy na później. Aby móc użyć argumentów w dowolnym miejscu w klasie (obiekcie) musimy przypisac je do **atrybutów**. Atrybuty można podzielić na atrybuty klasy i instancji. Te należące do instancji zaczynają się w klasie od przedrostka `self.`. 

### `self`
Nazwa `self` od której **musi** rozpoczynać się każda funkcja występująca w ciele klasy, jest po prostu reprezenatcją instancji (tu ciut kłamię - nie każda funkcja musi, ale na razie tak to zostawmy). Innymi słowy w naszym przykładzie

    gruszka1 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')
    
w środku klasy `self` zamienia się magicznie na `gruszka1`. Ten cały self nie musi nazwyać się `self`, może nazywoać się dowolnie - patrz plik `is19_aip_w03_katarzyna.ipynb` na classroom wykładu AiP. Nam wystarczy info, że jest to **zmienna reprezentująca instancję w środku klasy**. Aby odwołać się do dowolnego atrybutu instancji, musimy w klasie poprzedzić ten atrybut właśnie zmienną `self` i odwołaniem poprzez kropkę. 
"""


class Gruszka:
    '''
    Obiekt Gruszka opisuje nam wlasnosci gruszek.
    
    Dzieki obiektom Gruszka można skatalogować gruszki z naszego ogrodu.
    Aby poprawnie opisać gruszki, trzeba podać ich odmianę (str),
    wagę (num) oraz smak (str).

    Args:
        odmiana (str): trzyma odmiane owocu 
        waga (num): trzyma wage gruszek
        smak (str): opisuje smak gruszek (slodki, kwasny, itd.)

    Attributes:
        odmiana: tu przechowujemy informacje o odmianie 
        waga: tu przechowujemy informacje o wadze
        smak: tu przechowujemy informacje o smaku
    '''
    
    def __init__(self, odmiana, waga, smak):
        self.odmiana = odmiana
        self.waga = waga
        self.smak = smak
        
    def get_waga(self):
        return self.waga
    
    def get_odmiana(self):
        return self.odmiana
    
    def get_smak(self):
        return self.smak




# instancjonowanie
gruszka2 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')

# odwołanie do metody get_smak() instancji gruszka2
gruszka2.get_smak()

"""Jak widać funkcję `get_smak()` wywołuje się podobnie jak zwykłą funkcję, ale stoi przed nią nazwa instancji, tutaj `gruszka2`. Proszę zauważyć, że pomimo, iż w ciele klasy `Gruszka` funkcja `get_smak` posiada 1 parametr formalny `self`, to przy wywyłaniu tej funkcji w linii 5 powyżej **nie podajemy do niej żadnego agrumentu**. Jest to typowa notacja (interfejs) do wywołania funkcji które przynależą do instancji. Funkcje takie nazwyamy **metodami**.

> **Metoda** jest funkcją związaną z instancją. W szczególności przyjmuje ona o 1 argument mniej od swojego odpowiednika (funkcji) w ciele klasy. Dzieje się tak, ponieważ do argumentu `self` trafia adres instancji  (`gruszka2`) z której wywołujemy metodę. Pozostałe argumenty pojawiają się w wywołaniu tak jak w tradycyjnej funkcji.

Znów - magicznie nazwa instancji zostaje podstawiona w klasie pod zmienną `self`.

### getter-y
Powyższe funkcje nie są napisane przypadkiem. W ogólności nie powinniśmy odwoływac się do atrybutów instancji bezpośrednio przez
"""

print("Jaki smak ma gruszka?")
print(f"Gruszka jest {gruszka2.smak}")

"""Powinniśmy używać do tego właśnie owych funkcji `get_atrybut()`"""

print("Jaki smak ma gruszka?")
print(f"Gruszka jest {gruszka2.get_smak()}")

"""### setter-y
Podobnie ze zmianą atrybutów - też powinniśmy używac do tego pewnych specjanych funkcji - **setterów**.
"""

class Gruszka:
    '''
    Obiekt Gruszka opisuje nam wlasnosci gruszek.
    
    Dzieki obiektom Gruszka można skatalogować gruszki z naszego ogrodu.
    Aby poprawnie opisać gruszki, trzeba podać ich odmianę (str),
    wagę (num) oraz smak (str).

    Args:
        odmiana (str): trzyma odmiane owocu 
        waga (num): trzyma wage gruszek
        smak (str): opisuje smak gruszek (slodki, kwasny, itd.)

    Attributes:
        odmiana: tu przechowujemy informacje o odmianie 
        waga: tu przechowujemy informacje o wadze
        smak: tu przechowujemy informacje o smaku
    '''
    
    def __init__(self, odmiana, waga, smak):
        self.odmiana = odmiana
        self.waga = waga
        self.smak = smak
        
    def get_waga(self):
        return self.waga
    
    def get_odmiana(self):
        return self.odmiana
    
    def get_smak(self):
        return self.smak
    
    def set_waga(self, x):
        if isinstance(x, (int, float)):
            self.waga = x
        else:
            raise TypeError("Waga powinna byc liczba INT lub FLOAT")
    
    def set_odmiana(self, x):
        if isinstance(x, str):
            self.odmiana = x
        else:
            raise TypeError("Zmienna odmiana powinna byc lancuchem znakow STR")
    
    def set_smak(self, x):
        if isinstance(x, str):
            self.smak = x
        else:
            raise TypeError("Zmienna smak powinna byc lancuchem znakow STR")


    def __repr__(self):
        return '(Retional, String, String) (%s, %s, %s)' % (self.waga, self.odmiana, self.smak)

        # For call to str(). Prints readable form

    def __str__(self):
        return 'Ta gruszka ma wagę %s, odmiany %s, jest smaku %s ' % (self.waga, self.odmiana, self.smak)



# instancjonowanie
gruszka3 = Gruszka('General Leclerc', 330, 'kwaskowato-slodka')


print("str::: gruszka 3")
print(gruszka3)
print(repr(gruszka3))


# odwołanie do metody get_smak() instancji gruszka3
print("Jaki smak ma gruszka?")
print(f"Gruszka jest {gruszka3.get_smak()}")

# ustawienie zmiennej smak za pomoca set_smak(SMAK) dla instancji gruszka3
gruszka3.set_smak('wybitnie slodka')

print("Jaki smak ma gruszka?")
print(f"Gruszka jest {gruszka3.get_smak()}")

"""**Jeżeli czytacie ten dokument sami:** 
proszę zrobić zadanie domowe PD0302 (`is_aip_pd03.ipynb`).
"""



"""### Ćwiczenie 2
Dopisz gettery i settery do swojej klasy. Settery zaprogramuj *defensywnie*.
"""

x = isinstance(5, int)





"""> #### dekorowanie kodu*
Poprawne używanie getterów i setterów w jP nastepuje przy użyciu tzw. dekoratorów. Jeżeli chcą Państwo się z nimi zapoznać już, proszę zobaczyć dokument `is_aip_getset.ipynb`. Można też obejrzeć wideo z semestru letniego ra 2020-21 o tej samej nazwie.
"""



"""## Funkcje specjalne
Zaczynają się i kończą dwiema podłogami `__funkcja__`. Znamy już funkcję specjalną `__init__`.


### `__str__`
Gdy napiszemy w konsoli/komórce
```
print(100)
```
to funkcja `print` wyszukuje w obiekcie reprezentacji liczby `100` zrzutowanego na typ `str`. Gdy my napiszemy
"""
# gruszka()
print("OK")
gruszka3 = Gruszka('General Leclerc', 330, 'kwaskowato-slodka')
print(gruszka3)


print("after_OK")
class Complex:

    # Constructor
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    # For call to repr(). Prints object's information
    def __repr__(self):
        return 'Retional(%s, %s)' % (self.real, self.imag)

    # For call to str(). Prints readable form
    def __str__(self):
        return '%s + i%s' % (self.real, self.imag)


# Driver program to test above
t = Complex(10, 20)

# Same as "print t"
print(str(t))
print(t)
print(repr(t))
print(repr(t))



"""zupełnie jak"""

str(gruszka3)

"""dostaniemy informacje o obiekcie (jak wyżej), choć mało czytelne. Aby czytelne się stały musimy zaprogramować własną funkcję specjalnę 

```
def __str__(self):
    return 'jakiś string'
```

bo tej właśnie obie funkcje wyszukują w obiekcie. **Musi** ona **zwracać** ciąg znaków.
"""

class Gruszka:
    '''
    Obiekt Gruszka opisuje nam wlasnosci gruszek.
    
    Dzieki obiektom Gruszka można skatalogować gruszki z naszego ogrodu.
    Aby poprawnie opisać gruszki, trzeba podać ich odmianę (str),
    wagę (num) oraz smak (str).

    Args:
        odmiana (str): trzyma odmiane owocu 
        waga (num): trzyma wage gruszek
        smak (str): opisuje smak gruszek (slodki, kwasny, itd.)

    Attributes:
        odmiana: tu przechowujemy informacje o odmianie 
        waga: tu przechowujemy informacje o wadze
        smak: tu przechowujemy informacje o smaku
    '''
    
    def __init__(self, odmiana, waga, smak):
        self.odmiana = odmiana
        self.waga = waga
        self.smak = smak
        
    def get_waga(self):
        return self.waga
    
    def get_odmiana(self):
        return self.odmiana
    
    def get_smak(self):
        return self.smak
    
    def set_waga(self, x):
        if isinstance(x, (int, float)):
            self.waga = x
        else:
            raise TypeError("Waga powinna byc liczba INT lub FLOAT")
    
    def set_odmiana(self, x):
        if isinstance(x, str):
            self.odmiana = x
        else:
            raise TypeError("Zmienna odmiana powinna byc lancuchem znakow STR")
    
    def set_smak(self, x):
        if isinstance(x, str):
            self.smak = x
        else:
            raise TypeError("Zmienna smak powinna byc lancuchem znakow STR")
    
    def __str__(self):
        return f'Gruszka odmiany {self.get_odmiana()}, w smaku {self.get_smak()}, o wadze {self.get_waga()} gram'

# instancjonowanie
gruszka4 = Gruszka('Lipcówka kolorowa', 172, 'slodka')
print(gruszka4)

"""### `__repr__`
Podobnie budujemy funkcje specjalną `__repr__` zwracającą ciąg znaków, reprezentujący obiekt w konsoli.
"""

gruszka4

class Gruszka:
    '''
    Obiekt Gruszka opisuje nam wlasnosci gruszek.

    Args:
        odmiana (str): trzyma odmiane owocu 
        waga (num): trzyma wage gruszek
        smak (str): opisuje smak gruszek (slodki, kwasny, itd.)

    Attributes:
        odmiana: tu przechowujemy informacje o odmianie 
        waga: tu przechowujemy informacje o wadze
        smak: tu przechowujemy informacje o smaku
    '''
    
    def __init__(self, odmiana, waga, smak):
        self.odmiana = odmiana
        self.waga = waga
        self.smak = smak
        
    def get_waga(self):
        return self.waga
    
    def get_odmiana(self):
        return self.odmiana
    
    def get_smak(self):
        return self.smak
    
    def set_waga(self, x):
        if isinstance(x, (int, float)):
            self.waga = x
        else:
            raise TypeError("Waga powinna byc liczba INT lub FLOAT")
    
    def set_odmiana(self, x):
        if isinstance(x, str):
            self.odmiana = x
        else:
            raise TypeError("Zmienna odmiana powinna byc lancuchem znakow STR")
    
    def set_smak(self, x):
        if isinstance(x, str):
            self.smak = x
        else:
            raise TypeError("Zmienna smak powinna byc lancuchem znakow STR")
    
    def __str__(self):
        return f'Gruszka odmiany {self.get_odmiana()}, w smaku {self.get_smak()}, o wadze {self.get_waga()} gram'
    
    def __repr__(self):
        return f'Gruszka: {self.get_odmiana()}, smak: {self.get_smak()}, waga: {self.get_waga()} gram'

# instancjonowanie
gruszka5 = Gruszka('Bonkreta Williamsa', 222, 'nieziemsko slodka')
gruszka5



"""### Ćwiczenie 3
Zaimplementuj klasę. Każda instancja powinna mieć trzy dowolne atrybuty. Dopisz docstring. Dodaj gettery i settery. Zbuduj `__str__` i `__repr__`.

Student 1 wymyśla dla studenta 2 jaki obiekt ma opisać klasa, student 2 dla 3, student 3 dla 4, ..., i w końcu student N dla studenta 1.

"""



"""### Ćwiczenie 4
W parach, zaprogramuj klasy: doc/get/set/str/repr + 3 dowolne modyfikatory.

1. `Krowa`
2. `Kaczka`
3. `Owca`
4. `Lama`
5. `Pajak`
6. `Nietoperz`
"""

print("###########################################################################################################")
# @@@@@@@@@@@@@@@@@@@@__________KROWA______@@@@@@@@@@@@@@@@@@

class Krowa:
    '''
   Obiekt Krowa opisuje nam profil krowy.

   Dzieki obiektom Krowa można skatalogować Krowy z naszej farmy.
   Aby poprawnie opisać krowy, trzeba podać ich gatunek (str),
   wagę (num) oraz wiek (str).

   Args:
       gatunek (str): trzyma gatunek krowy
       waga (num): trzyma wage wiek
       wiek (num): opisuje wiek krowy

   Attributes:
       gatunek: tu przechowujemy informacje o gatunek
       waga: tu przechowujemy informacje o wadze
       wiek: tu przechowujemy informacje o wieku
'''

    def __init__(self, gatunek, waga, wiek):
        self.gatunek = gatunek
        self.waga = waga
        self.wiek = wiek

    def get_waga(self):
        return self.waga

    def get_gatunek(self):
        return self.gatunek

    def get_wiek(self):
        return self.wiek

    def set_waga(self, x):
        if isinstance(x, (int, float)):
            self.waga = x
        else:
            raise TypeError("Waga powinna byc liczba INT lub FLOAT")

    def set_gatunek(self, x):
        if isinstance(x, str):
            self.gatunek = x
        else:
            raise TypeError("Zmienna odmiana powinna byc lancuchem znakow STR")

    def set_wiek(self, x):
        if isinstance(x, int):
            self.wiek = x
        else:
            raise TypeError("Zmienna powinna być liczbą INT")

    def __str__(self):
        return f'Krowa gatunku {self.get_gatunek()}, w wieku {self.get_wiek()}, o wadze {self.get_waga()} kilogramów'

    def __repr__(self):
        return f'Krowa: {self.get_gatunek()}, wiek: {self.get_wiek()}, waga: {self.get_waga()} kilogram'

krowa_001 = Krowa('Polska', 5, 120)

print(krowa_001)

print("###########################################################################################################")
print("#########################################_________KACZKA_______________##################################################################")

class Kaczka:
    '''
   Obiekt Kaczka opisuje nam profil Kaczki.

   Dzieki obiektom klasy Kaczki można skatalogować Kaczki z naszej farmy.
   Aby poprawnie opisać Kaczki, trzeba podać ich gatunek (str),
   wagę (num) oraz wiek (str).

   Args:
       gatunek (str): trzyma gatunek krowy
       waga (num): trzyma wage wiek
       wiek (num): opisuje wiek krowy

   Attributes:
       gatunek: tu przechowujemy informacje o gatunek
       waga: tu przechowujemy informacje o wadze
       wiek: tu przechowujemy informacje o wieku
'''

    def __init__(self, gatunek, waga, wiek):
        self.gatunek = gatunek
        self.waga = waga
        self.wiek = wiek

    def get_waga(self):
        return self.waga

    def get_gatunek(self):
        return self.gatunek

    def get_wiek(self):
        return self.wiek

    def set_waga(self, x):
        if isinstance(x, (int, float)):
            self.waga = x
        else:
            raise TypeError("Waga powinna byc liczba INT lub FLOAT")

    def set_gatunek(self, x):
        if isinstance(x, str):
            self.gatunek = x
        else:
            raise TypeError("Zmienna odmiana powinna byc lancuchem znakow STR")

    def set_wiek(self, x):
        if isinstance(x, int):
            self.wiek = x
        else:
            raise TypeError("Zmienna powinna być liczbą INT")

    def __str__(self):
        return f'Kaczka gatunku {self.get_gatunek()}, w wieku {self.get_wiek()} lat, o wadze {self.get_waga()} kilogramów'

    def __repr__(self):
        return f'Kaczka: {self.get_gatunek()}, wiek: {self.get_wiek()}, waga: {self.get_waga()} kilogram'

kaczka_001 = Kaczka('Pospolita', 1, 2)

print(kaczka_001)

print("###########################################################################################################")



"""# Studium przypadku 2 - Rakieta

### `Rakieta`
Wracamy do klasy `Rakieta`. Może ona robić różne rzeczy, ale przede wszystkim jest obiektem latającym. 
Może mieć kilka ciekawych i typowych dla rakiet atrybutów: waga, ilość paliwa, położenie, prędkość... 
Pewnie i więcej, ale proszę sobie wyobrazić coś takiego:

```
 ∧
 |
 |               ∧
 |              / \
y|--------------|o|  pozycja = (x, y)
 |              | |
 |               ᚄ
 |               |
 |               |
 +-------------------------->
                 x
```

Zapomnimy o większości problemów z rakietami i ograniczymy się do latania rakietą. Będziemy po prostu opisywać, jak na obrazku powyżej położenie rakiety w układzie kartezjańskim. 

### 2.1. Zaczniemy krok po kroku, od najprostszej realizacji klasy Rakieta
"""

class Rakieta:
    def __init__(self, pozycja=(0, 0)):
        self.pozycja = pozycja
        
    def get_pozycja(self):
        return self.pozycja
    
    def set_pozycja(self, var):
        'ustaw var jako nowa wartość pozycja'
        self.pozycja = var
    
    def __repr__(self):
        return f'Rakieta w pozycji {self.get_pozycja()}'
    
    def __str__(self):
        return self.__repr__()
    
    
r = Rakieta()

rakieta_001 = Rakieta(pozycja=(5, 5))
print(r)
print(rakieta_001)




"""### Ćwiczenie 2.1
Na bazie klasy `Rakieta` zbuduj klasę (każdy student inną).

1. `Bocian`
2. `Kruk`
3. `Czapla`
4. `Koliber`
5. `Papuga`
6. `Kawka`
7. ...
"""

# colors = ["czarny", ...... ]

class Bocian:
    def __init__(self, kolor, pozycja=(0, 0, 0)):
        self.pozycja = pozycja
        self.kolor = kolor

    def get_pozycja(self):
        return self.pozycja

    def get_kolor(self):
        return self.kolor

    def set_pozycja(self, var):
        'ustaw var jako nowa wartość pozycja'
        assert isinstance(var, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(var) == 3, 'pozycja powinna mieć 3 elementy'
        assert all([isinstance(el, (int, float)) for el in var]), 'elementy pozycja powinna być liczbami'
        assert all(el >= 0 for el in var[1:3:1]), 'elementy pozycja 2 i 3 powinna być liczbami nieujemnymi'

        self.pozycja = var
        # assert isinstance(var, (tuple, list)), 'pozycja powinna być listą/krotką'
        # assert len(var) == 2, 'pozycja powinna mieć 2 elementy'
        # assert all([isinstance(el, (int, float)) for el in var]), 'elementy pozycja powinna być liczbami'
        # assert var[1] >= 0, 'drugi element pozycji powinien być nieujemny'


    def set_kolor(self, var):
        'ustaw var jako nowa wartość koloru'
        assert isinstance(var, str), 'pozycja powinna być stringiem'
        self.kolor = var

    # # napisz assert dla kolorów z listy, zaakceptuj tylko te wypisane !!!!
    # # albo kolory 3 zmionnych int z RGB
    # def set_kolor_napisa(self()):
    #
    # def set_kolor_RGB(self()):


    def __repr__(self):
        return f'Bocian w pozycji {self.get_pozycja()}'

    def __str__(self):
        return self.__repr__()




bocian_001 = Bocian("czarny", pozycja=(500, 500, 500))
bocian_002 = Bocian("niebieski", pozycja=[300, 300, 300])


print(bocian_001)
print(bocian_002)

print("______________________________________________________________________________________")
bocian_001.set_pozycja((500, 500, 500))
# bocian_001.set_kolor(400)

"""
Takie klasy też będą latać, jak powyższa rakieta. Dodaj 1 parametr do `__init__` wyróżniający swoją klasę np: kolor, wagę. 
Przypisz go do atrybutu instancji (`self`), dodaj setter i getter.
"""



"""### 2.2. Settery defensywne
Settery możemy wykorzystywać do nieco innych rzeczy niż proste ustawianie wartości atrybutów instancji, np: do sprawdzania, że użytkownik podaje poprawne dane. Na przykład
"""

class Rakieta:
    def __init__(self, pozycja=(0, 0)):
        self.pozycja = pozycja
        
    def get_pozycja(self):
        return self.pozycja
    
    def set_pozycja(self, var):
        assert isinstance(var, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(var) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in var]), 'elementy pozycja powinna być liczbami'
        assert var[1] >= 0, 'drugi element pozycji powinien być nieujemny'
        self.pozycja = var
    
    def __repr__(self):
        return f'Rakieta w pozycji {self.get_pozycja()}'
    
    def __str__(self):
        return self.__repr__()
    
    
r = Rakieta()
print(r)

"""### Ćwiczenie 2.2
Zmodyfikuj settery swojej klasy w podobny sposób do powyższego.
"""



"""### 2.3. Setter w `__init__`
Skoro nasz setter sprawdza czy z wielkością jaką chcemy ustawić dla danego atrybutu wszystko jest OK, możemy ją użyć też do inicjalizacji instancji
"""

class Rakieta:
    def __init__(self, nazwa, pozycja=(0, 0)):
        self.set_nazwa(nazwa),
        assert isinstance(nazwa, str), 'pozycja powinna być stringiem'
        assert len(nazwa) < 10, 'nazwa nie moze być dłuższa od 10 znaków'
        self.nazwa = nazwa

        self.set_pozycja(pozycja)
        assert isinstance(pozycja, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(pozycja) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in pozycja]), 'elementy pozycja powinna być liczbami'
        assert pozycja[1] >= 0, 'drugi element pozycji powinien być nieujemny'
        self.pozycja = pozycja
        
    def get_pozycja(self):
        return self.pozycja

    def get_nazwa(self):
        return self.nazwa

    def set_nazwa(self, name):
        assert isinstance(name, str), 'pozycja powinna być stringiem'
        assert len(name) < 10, 'nazwa nie moze być dłuższa od 10 znaków'
        self.nazwa = name


    def set_pozycja(self, var):
        assert isinstance(var, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(var) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in var]), 'elementy pozycja powinna być liczbami'
        assert var[1] >= 0, 'drugi element pozycji powinien być nieujemny'
        self.pozycja = var
    
    def __repr__(self):
        return f'Rakieta w pozycji {self.get_pozycja(), self.get_nazwa()}'
    
    def __str__(self):
        return self.__repr__()

# r = Rakieta((1, 2))

# print(r)
print("_________________________________________________________________________________________________________________")
# test = Rakieta((3, 0))
# print(test)
print("_________________________________________________________________________________________________________________")
test_name = Rakieta("cos", (3, 0))
print(test_name)

# r = Rakieta((1, 2))
try:
    r1 = Rakieta('ala')
except AssertionError as e:
    print(e)

try:
    r1 = Rakieta((0, 1, 2))
except AssertionError as e:
    print(e)

"""### Ćwiczenie 2.3
Zmodyfikuj `__init__` swojej klasy w podobny sposób do powyższego dla obu atrybutów.
"""



"""### 2.4. Funkcje klas

Niektóre własności obiektów nie muszą być związane z instancjami. Np: sprawdzanie czy `pozycja` jest dwuelementową 
listą o elementach liczbowych nie musi być specyficzne dla instancji (taką funkcją możemy sprawdzać dowolne *inne* dwuelementowe 
listy o wartośćiach liczbowych). Dlatego możemy taką funkcjonalność zbudować jako funkcję specyficzną dla klasy. 
Dla takich funkcji pierwszym parametrem nie będzie `self`.
"""

class Rakieta:
    def __init__(self, nazwa, pozycja=(0, 0)):
        self.set_nazwa(nazwa),
        assert isinstance(nazwa, str), 'pozycja powinna być stringiem'
        assert len(nazwa) < 10, 'nazwa nie moze być dłuższa od 10 znaków'
        self.nazwa = nazwa

        self.set_pozycja(pozycja)
        assert isinstance(pozycja, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(pozycja) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in pozycja]), 'elementy pozycja powinna być liczbami'
        assert pozycja[1] >= 0, 'drugi element pozycji powinien być nieujemny'
        self.pozycja = pozycja
    def sprawdz_pozycje(pozycja):  # nie ma self!
        assert isinstance(pozycja, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(pozycja) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in pozycja]), 'elementy pozycja powinna być liczbami'
        assert pozycja[1] >= 0, 'drugi element pozycji powinien być nieujemny'


    def sprawdz_nazwa(nazwa):  # nie ma self!
        assert isinstance(nazwa, str), 'pozycja powinna być stringiem'
        assert len(nazwa) < 10, 'nazwa nie moze być dłuższa od 10 znaków'

    def get_pozycja(self):
        return self.pozycja

    def get_nazwa(self):
        return self.nazwa

    def set_nazwa(self, name):
        Rakieta.sprawdz_nazwa(name)
        self.nazwa = name
    def set_pozycja(self, var):
        Rakieta.sprawdz_pozycje(var)  # lub __class__.sprawdz_pozycje(var)
        self.pozycja = var
    
    def __repr__(self):
        return f'Rakieta w pozycji {self.get_pozycja(), self.get_nazwa()}'
    
    def __str__(self):
        return self.__repr__()
    
print("*******************************************************************")

r = Rakieta("dos", (1, 1))
print(r)



try:
    r1 = Rakieta('ala')
except AssertionError as e:
    print(e)

try:
    r1 = Rakieta((0, 1, 2))
except AssertionError as e:
    print(e)

"""### Ćwiczenie 2.4
Dopisz funkcje klas `sprawdz_AAA` dla atrybutów klasy. Wykorzystaj odwołanie `__class__.sprawdz_AAA` w setterach.
"""


"""### 2.4. Modyfikacje stanu instancji

Jak przemieścić rakietę? Warto na początku zaprogramować najpierw ogólną funkcję (abstrakcja!)
```
def przesun_rakiete(self, przesuniecie):
    x, y = self.get_pozycja()  # czytaj obecną pozycję
    dx, dy = przesuniecie  # przesuniecie
    nowa_pozycja = (x + dx, y + dy)  # ustaw nową pozycję
    self.set_pozycja(nowa_pozycja)
``` 

a później mając już taką funkcję korzystać z niej przy przestawianiu rakiety w lewo-prawo-górę-dół
"""

class Rakieta:
    def __init__(self, pozycja=(0, 0)):
        self.set_pozycja(pozycja)
        
    def sprawdz_pozycje(pozycja):
        assert isinstance(pozycja, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(pozycja) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in pozycja]), 'elementy pozycja powinna być liczbami'
        assert pozycja[1] >= 0, 'drugi element pozycji powinien być nieujemny'
        
    def get_pozycja(self):
        return self.pozycja
    
    def set_pozycja(self, var):
        __class__.sprawdz_pozycje(var)
        self.pozycja = var
        
    def przesun_rakiete(self, przesuniecie):
        x, y = self.get_pozycja()  # czytaj obecną pozycję
        dx, dy = przesuniecie  # przesuniecie
        nowa_pozycja = (x + dx, y + dy)  # ustaw nową pozycję
        self.set_pozycja(nowa_pozycja)

    def lec(self):
        kierunek = input("W którą stronę chcesz lecieć? ")
        assert kierunek in ("lewo", "prawo", "góra", "dół"), 'zły kierunek'
        ile = int(input("Jak daleko chcesz lecieć w" + kierunek))
        assert isinstance(ile, (int, float)), 'pozycja powinna być int/float'
        if kierunek == "lewo":
            self.przesun_rakiete((-ile, 0))
        elif kierunek == "prawo":
            self.przesun_rakiete((ile, 0))
        elif kierunek == "góra":
            self.przesun_rakiete((0, ile))
        elif kierunek == "dół":
            self.przesun_rakiete((0, -ile))
        return ""



    def __repr__(self):
        return f'Rakieta w pozycji {self.get_pozycja()}'
    
    def __str__(self):
        return self.__repr__()


print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
"""
r = Rakieta()
print(r.get_pozycja())

print(r.lec())
print(r.get_pozycja())


r.przesun_rakiete((1, 1))
print(r)

r.przesun_rakiete((-1, 1))
print(r)
"""

# NEXT TIME KLASY I METODY ABSTRAKCYJNE!!!!!!!!!!!!   START HERE!!!!!!

"""### Ćwiczenie 2.4
Dopisz lekko abstrakcyjną funkcję `lataj(self, ruch)` do swojej ptasiej klasy.
"""

print("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz")

from abc import ABC, abstractmethod


class Ptak(ABC):
    def __init__(self, gatunek, waga):
        self.gatunek = gatunek
        self.waga = waga

    @abstractmethod
    def lataj(self, ruch):
        pass

    def spij(self, jak):
        pass

    def w_lewo(self, lewo):
        print("lece w lewo o " + str(lewo))

    def w_prawo(self, prawo):
        print("lecę w prawo o " + str(prawo))

    def w_górę(self, gora):
        print("lecę w góre o " + str(gora))

    def w_dół(self, dol):
        print("lecę w dół o " + str(dol))

class wrobel(Ptak):
    def lataj(self, ruch):
        print("latam jak wróbel w kierunku " + ruch)

    def spij(self, jak):
        print("wróbel śpi na " + jak)


class wrona(Ptak):
    def lataj(self, ruch):
        print("latam jak wrona w kierunku " + ruch)

    def spij(self, jak):
        print("wrona śpi na " + jak)

    def kracz(self, dzwiek):
        print("kracze jak wrona " + dzwiek)


class kura(Ptak):
    def lataj(self, ruch):
        print("latam jak wróbel w kierunku " + ruch)

    def spij(self, jak):
        print("kura śpi na " + jak)

    def wysiaduje(self, co):
        print("kura znosi" + co)


wrobel1 = wrobel("bialy", 10)
print(wrobel1.gatunek)

print(wrobel1.lataj("lewym"))

wrona1 = wrona("czarna", 10)
print(wrona1.kracz("bo to jest normalne"))

kura1 = kura("polska", 10)
print(kura1.gatunek)

print(kura1.spij("stojaco"))

wrobel2 = wrobel("szary", 25)
print(wrobel2.w_lewo(10))

import random

ilosc_skokow = 10
for i in range(ilosc_skokow):
    # góra czy dół?
    # print(wrobel1.w_lewo(i))
    print(wrobel1.w_lewo(round(random.random(),1)))

    dy = random.randint(0, 4)
    if dy == 1:
        print(wrobel1.w_lewo(round(random.random(),1)))
    elif dy == 2:
        print(wrobel1.w_prawo(round(random.random(),1)))
    elif dy == 3:
        print(wrobel1.w_górę(round(random.random(),1)))
    elif dy == 4:
        print(wrobel1.w_dół(round(random.random(),1)))


# Nie da się stworzyć obiektu klasy abstrakcyjnej, jest tylko szablonem dla konkretnych klass
# ptak1 = Ptak("biały", 50)

# tutaj start next time~!!!!

"""### 2.5. Inne modyfikacje
Wykorzystanie abstrakcyjnej funkcji `przesun_rakiete` do sterowania rakietą. Zbudujemy 4 funkcje `w_gore`, `w_dol`, `w_prawo` i `w_lewo`.
"""
# import random
#
# print(round(random.random(),1))

class Rakieta:
    def __init__(self, pozycja=(0, 0)):
        self.set_pozycja(pozycja)
        
    def sprawdz_pozycje(pozycja):
        assert isinstance(pozycja, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(pozycja) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in pozycja]), 'elementy pozycja powinna być liczbami'
        assert pozycja[1] >= 0, 'drugi element pozycji powinien być nieujemny'
        
    def get_pozycja(self):
        return self.pozycja
    
    def set_pozycja(self, var):
        __class__.sprawdz_pozycje(var)
        self.pozycja = var
        
    def przesun_rakiete(self, przesuniecie):
        x, y = self.get_pozycja()  # czytaj obecną pozycję
        dx, dy = przesuniecie  # przesuniecie
        nowa_pozycja = (x + dx, y + dy)  # ustaw nową pozycję
        self.set_pozycja(nowa_pozycja)
        
    def w_gore(self, var):
        self.przesun_rakiete((0, var))
    
    def __repr__(self):
        return f'Rakieta w pozycji {self.get_pozycja()}'
    
    def __str__(self):
        return self.__repr__()

r = Rakieta()
print(r)

r.w_gore(4)
print(r)

print("qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq")
from abc import ABC, abstractmethod

class statek_NASA(ABC):
    def __init__(self, pozycja=(0, 0)):
        self.set_pozycja(pozycja)

    def sprawdz_pozycje(pozycja):
        assert isinstance(pozycja, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(pozycja) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in pozycja]), 'elementy pozycja powinna być liczbami'
        assert pozycja[1] >= 0, 'drugi element pozycji powinien być nieujemny'

    @abstractmethod
    def przesun_rakiete(self, ruch):
        pass

    def set_pozycja(self, var):
        __class__.sprawdz_pozycje(var)
        self.pozycja = var

    def __str__(self):
        return f'Rakieta w pozycji {self.pozycja}'


class satelita(statek_NASA):
    def przesun_rakiete(self, ruch):
        print("satelita przesunie się w pozycje " + ruch)


satelita_1 = satelita((2, 1))
print(satelita_1)

"""### Ćwiczenie 2.5
Dopisz resztę funkcji: `w_dol`, `w_prawo` i `w_lewo`.
"""



class Rakieta:
    def __init__(self, pozycja=(0, 0)):
        self.set_pozycja(pozycja)
        
    def sprawdz_pozycje(pozycja):
        assert isinstance(pozycja, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(pozycja) == 2, 'pozycja powinna mieć 2 elementy'
        assert all([isinstance(el, (int, float)) for el in pozycja]), 'elementy pozycja powinna być liczbami'
        assert pozycja[1] >= 0, 'drugi element pozycji powinien być nieujemny'
        
    def get_pozycja(self):
        return self.pozycja
    
    def set_pozycja(self, var):
        __class__.sprawdz_pozycje(var)
        self.pozycja = var
        
    def przesun_rakiete(self, przesuniecie):
        x, y = self.get_pozycja()  # czytaj obecną pozycję
        dx, dy = przesuniecie  # przesuniecie
        nowa_pozycja = (x + dx, y + dy)  # ustaw nową pozycję
        self.set_pozycja(nowa_pozycja)
        
    def w_gore(self, var):
        self.przesun_rakiete((0, var))
    
    def w_dol(self, var):
        self.przesun_rakiete((0, -var))
        
    def w_prawo(self, var):
        self.przesun_rakiete((var, 0))
        
    def w_lewo(self, var):
        self.przesun_rakiete((-var, 0))
        
    def laduj(self):
        x, y = self.get_pozycja()
        self.set_pozycja((x, 0))
    
    def __repr__(self):
        return f'Rakieta w pozycji {self.get_pozycja()}'
    
    def __str__(self):
        return self.__repr__()

"""### 2.6. Latamy rakietą"""

# Commented out IPython magic to ensure Python compatibility.
import random

rakieta = Rakieta()
pozycja = []
pozycja.append(rakieta.get_pozycja())

# start pionowy
rakieta.w_gore(10)
pozycja.append(rakieta.get_pozycja())

ilosc_skokow = 10
for i in range(ilosc_skokow):
    # góra czy dół?
    dy = random.randint(0, 10)
    if random.random() > 0.5:
        rakieta.w_gore(dy)
    else:
        try:
            rakieta.w_dol(dy)
        except:
            pass
    
    # lewo czy prawo?
    dx = random.randint(0, 100)
    if random.random() > 0.5:
        rakieta.w_prawo(dx)
    else:
        rakieta.w_lewo(dx)
    
    pozycja.append(rakieta.get_pozycja())
    
#lądujemy
rakieta.laduj()
pozycja.append(rakieta.get_pozycja())
print(pozycja)

### Odkomentuj jeżeli chcesz zobaczyć jak latała rakieta...
# import pylab
# # %matplotlib inline
# x, y = zip(*pozycja)
# pylab.plot(x, y, '*-')
# pylab.plot(x[:1], y[:1], '^r', markersize=10)
# pylab.plot(x[-1:], y[-1:], 'vr', markersize=10)

"""### Ćwiczenie 2.6
Proszę dać ptakom polatać.
"""



# stworzyc liste wróbuli ktorym damy polatać !!!!!

"""**Jeżeli czytacie ten dokument sami:** 
Pora na zadania domowe PD0303 i PD0304. Proszę nie zapomnieć o zadaniu specjalnym PD03X.
"""

