# -*- coding: utf-8 -*-
"""is_aip_lab05_pzo3 (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1npf4nWj_KPGUjah8gdpxPPH7-qjgBvDH

# Algorytmy i programowanie

## Programowanie zorientowane obiektowo (PZO), część 3 - klasa jako struktura danych
"""



"""Na poprzednich dwóch labach omówiliśmy sobie pokrótce jak budować proste klasy definiujące nam obiekty oraz jak skonstruować hierarchię klas w oparciu o **dziedziczenie**. Pokazaliśmy jak klasa `Gruszka`, która reprezentowała nam rzeczywisty obiekt - gruszkę, może dziedziczyć pola po super-klasie **Owoc**.

Zerknijcie poniżej, to te same podstawowe klasy, co poprzednio, ale z nieco innym *docstring*iem. Ten jest w stylu [Numpy/Scipy](https://numpydoc.readthedocs.io/en/latest/format.html). Styl jest równie czytelny jak googlowski. Jeżeli planują Państwo karierę w Data Science, warto przede wszystkim opanowac ten typ tworzenia dokumentacji.

**Jeżeli czytacie ten dokument sami:**
Możecie teraz zrobić zadanie P05X. Polecam teraz - przyda się przy budowaniu dokumentacji do waszych klas.
"""

class Owoc(object):
    '''
    Obiekt Owoc opisuje nam wlasnosci owocow.

    Owocami jako rodzajem pozywienia okreslane
    są częsci roslin o grubej warstwie miazszu i
    przyjemnym, zwykle slodkim smaku i zapachu.

    Parameters
    ----------
    rodzaj: str
        rodzaj owocu
    odmiana: str
        trzyma odmiane owocu
    waga: int or float
        trzyma wage owocu
    smak: str
        opisuje smak owocu (slodki, kwasny, itd.)

    Attributes
    ----------
    rodzaj: tu przechowujemy informacje o parametrze rodzaj
    odmiana: tu przechowujemy informacje o parametrze odmiana
    waga: tu przechowujemy informacje o parametrze waga
    smak: tu przechowujemy informacje o parametrze smak

    Examples
    --------
    >>> gruszka = Owoc('gruszka', 'General Leclerc', 130, 'kwaskowato-slodki')
    >>> jablko = owoc('jablko', 'Ligol', 89, 'chrupiacy, slodki, delikatnie kwaskowaty')
    >>> hurma = Owoc('hurma', 'Diospyros lotus', 94, 'slodki')
    '''

    def __init__(self, rodzaj, odmiana, waga, smak):
        self.rodzaj = rodzaj
        self.odmiana = odmiana
        self.waga = waga
        self.smak = smak

    def __str__(self):
        ret = f"{self.smak} owoc, {self.rodzaj} "
        ret += f"z klasy {self.__class__.__name__} "
        ret += f"w odmianie {self.odmiana} i wadze {self.waga}"
        return ret

    def __repr__(self):
        return 'instancja klasy ' + self.__class__.__name__

    def get_rodzaj(self):
        return "Owoc: " + self.rodzaj


class Gruszka(Owoc):
    '''
    Obiekt Gruszka opisuje nam wlasnosci gruszek.

    Tutaj powinien byc nieco dluzszy tekst opisujacy klase Gruszka.
    Moze kiedys bedzie to mialo sens, ale na razie nie ma.

    Parameters
    ----------
    odmiana: str
        trzyma odmiane owocu
    waga: int or float
        trzyma wage owocu
    smak: str
        opisuje smak owocu (slodki, kwasny, itd.)

    Attributes
    ----------
    odmiana: tu przechowujemy informacje o parametrze odmiana
    waga: tu przechowujemy informacje o parametrze waga
    smak: tu przechowujemy informacje o parametrze smak

    Example
    -------
    >>> gruszka1 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')
    >>> gruszka2 = Gruszka('Komisowka', 110, 'slodka')
    >>> gruszka1.waga
    130
    '''

    def __init__(self, odmiana, waga, smak):
        super(Gruszka, self).__init__('gruszka', odmiana, waga, smak)

    def info(self):
        return super(Gruszka, self).get_rodzaj()

gruszka1 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')
gruszka2 = Gruszka('Komisowka', 110, 'slodka')
if gruszka1.waga > gruszka2.waga:
    print(f"Ja bym brał {gruszka1}", gruszka1.info())
else:
    print(f"Ja bym brał {gruszka2}")

"""### `super(Klasa, self)`
Podczas gdy przykłady z lab 03 wywołują `super()` bez żadnych parametrów, `super()` może również przyjmować 
dwa parametry: pierwszy to klasa, a drugi parametr to obiekt, zupełnie jak w przykładzie powyżej mamy wywołanie 
`super(Gruszka, self)`. Z poziomu dowolnej klasy dziedziczącej w danej hierarchii możemy odwoływać się do 
dowonlej klasy nadrzędnej, niezależnie od poziomu.
"""

class Czworobok:
    "Obiekt Czworobok opisuje nam wlasnosci czworoboków."

    def __init__(self, bok_1, bok_2, bok_3, bok_4):
        self.bok_1 = bok_1
        self.bok_2 = bok_2
        self.bok_3 = bok_3
        self.bok_4 = bok_4

    def obwod(self):
        return self.bok_1 + self.bok_2 + self.bok_3 + self.bok_4


class Prostokat(Czworobok):
    "Obiekt Prostokat opisuje nam wlasnosci prostokatow."

    def __init__(self, bok_1, bok_2):
        super(Prostokat, self).__init__(bok_1, bok_2, bok_1, bok_2)

    def pole(self):
        return self.bok_1 * self.bok_2


class Kwadrat(Prostokat):
    "Obiekt Kwadrat opisuje nam wlasnosci kwadratow."

    def __init__(self, bok):
        self.bok = bok
        super(Kwadrat, self).__init__(bok, bok)


class Szescian(Kwadrat):
    "Obiekt Szescian opisuje nam wlasnosci szescianow."

    def pole_powierzchni_calkowitej(self):
        pps = super(Kwadrat, self).pole()
        return pps * 6

    def objetosc(self):
        pps = super(Kwadrat, self).pole()
        return pps * self.bok

s = Szescian(3.14)
s.objetosc() == 3.14 ** 3

"""
dziadek kim jest, wzrost, waga
  ojciec(dziadek) kim jest, wzrost, waga, zona
    syn(ojciec) kim jest, wzrost, waga, wiek
"""

class Dziadek:
    '''
       Obiekt Dziadek opisuje nam dziadka.

       Dziadka opisujemy imieniem, nazwiskiem, wzrostem i waga.

       :param str imie: imie dziadka
       :param str dziadek: nazwisko dziadka
       :param int wzrost: wzrost dziadka
       :param int waga: waga dziadka

       :method str przedstaw się: zwraca imie i nazwisko dziadka -> str
    '''
    def __init__(self, imie, nazwisko, wzrost, waga):
        self.imie = imie
        self.nazwisko = nazwisko
        self.wzrost = wzrost
        self.waga = waga

    def __str__(self):
        ret = f"Dziadek ma naimie {self.imie} i nazwya się {self.nazwisko}, waży {self.waga} i jego wzrost to {self.wzrost}"
        return ret

    def __repr__(self):
        return 'instancja klasy ' + self.__class__.__name__

    def sprawdz_(debet):
        assert isinstance(debet, int), 'debet musi być liczbą ujemną'
        assert debet < 0, 'debet zawsze ujemny --'
        return

    def sprawdz_imie(imie):
        assert isinstance(imie, str), 'imie musi byc stringiem'
        return

    def set_imie(self, var):
        __class__.sprawdz_imie(var)
        self.imie = var
        return ""

    def sprawdz_nazwisko(nazwisko):
        assert isinstance(nazwisko, str), 'nazwisko musi byc stringiem'
        return

    def set_nazwisko(self, var):
        __class__.sprawdz_nazwisko(var)
        self.nazwisko = var
        return ""

    def sprawdz_wzrost(wzrost):
        assert isinstance(wzrost, int), 'wzrost musi byc int'
        return

    def set_wzrost(self, var):
        __class__.sprawdz_wzrsot(var)
        self.wzrost = var
        return ""

    def sprawdz_waga(waga):
        assert isinstance(waga, int), 'waga musi byc int'
        return

    def set_waga(self, var):
        __class__.sprawdz_waga(var)
        self.waga = var
        return ""

    def get_imie(self):
        return self.imie

    def get_nazwisko(self):
        return self.nazwisko

    def get_waga(self):
        return self.waga

    def get_wzrost(self):
        return self.wzrost

class Ojciec(Dziadek):

    def __init__(self, imie, nazwisko, wzrost, waga, zona):
        super().__init__(imie, nazwisko, wzrost, waga)
        self.zona = zona

    def __str__(self):
        ret = f"Ojciec ma naimie {self.imie} i nazwya się {self.nazwisko}, waży {self.waga}, jego wzrost to {self.wzrost} i ma żone o imieniu {self.zona}"
        return ret

    def sprawdz_zona(zona):
        assert isinstance(zona, str), 'zona musi byc stringiem'
        return

    def set_zona(self, var):
        __class__.sprawdz_zona(var)
        self.zona = var
        return ""

    def get_zona(self):
        return self.zona


class Syn(Ojciec):

    def __init__(self, imie, nazwisko, wzrost, waga, zona, wiek):
        super().__init__(imie, nazwisko, wzrost, waga, zona)
        self.wiek = wiek

    def __str__(self):
        ret = (f"Syn ma naimie {self.imie} i nazwya się {self.nazwisko}, waży {self.waga},"
               f" jego wzrost to {self.wzrost}, ma żone o imieniu {self.zona} i jest w wieku {self.wiek}")
        return ret

    def sprawdz_wiek(wiek):
        assert isinstance(wiek, int), 'zona musi byc int'
        return

    def set_wiek(self, var):
        __class__.sprawdz_wiek(var)
        self.wiek = var
        return ""

    def get_wiek(self):
        return self.wiek

    def podaj_waga(self):
        return super(Syn, self).get_waga()
        #mozlwe odwołanie do każdej nadrzędnej klasy, np get_waga która jest metodą u dziadka


Syn_1 = Syn("Jan", "Prosty", 200, 90, "Zosia", 40)

print(Syn_1.podaj_waga())

print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")

#START TUTAJ NEXT TIME!!!!!!!!!!!!

"""> **Uwaga**
podczas gdy naprawdę sporo majstrujemy przy parametrach funkcji `super()` w celu pokazania jak to działa, 
odradzam regularne programowaanie w ten sposób.
Bezparametrowe wywołanie `super()` jest zalecane i wystarczające w większości przypadków, a konieczność 
regularnej zmiany hierarchii wyszukiwania może wskazywać na większy problem projektowy, który należy raczej 
rozwiązać wracając do projektu klasy, nie za pomocą tego typu *haków*.
"""



"""### jeszcze o funkcji `__init__`
Poprzez proste nawiązanie do innych, historycznie starszych języków programowania, funkcję specjalną `__init__`
nazywa się potocznie **konstruktorem**, choć jest w tym przypadku raczej **funkcją inicjalizacyjną**, która 
wywoływana jest jako pierwsza podczas inicjalizacji nowego obiektu. Służy ona do przekazywania wartości do atrybutów 
instancji czy klasy, do wypełnienia wzorca obiektu. Od programisty zależy co chciałby zawrzeć w tej funkcji a nawet 
czy w ogóle funkcja ta pojawi się w definicji klasy, przecież nie zawsze musi...
"""

class AddNumber:
    """Silly class"""

    def __init__(self, x=0):
        self.value = x

    def add_number(self, number):
        self.value += number


class AddOne(AddNumber):
    """Even more silly class"""

    def add_one(self):
        self.add_number(1)


anp = AddOne()
print("init value: ", anp.value)
anp.add_one()
print("add one: ", anp.value)



"""### Ćwiczenie 1
Sluis Van (http://www.sluisvan.net) to strona opisująca wszelkiego rodzaju statki kosmiczne ze świata Gwiezdnych wojen. 
Proszę wybrać sobie 1 statek (unikalny) i na bazie klasy `RakietaBojowa` którą widać poniżej stworzyć swoją klasę, 
dziedzicząc z `RakietaBojowa`, ale dodając 1 dodatkową funkcjonalność (get/set i modyfikacja `__repr__`). 
Klasa `Rakieta` to kopia z poprzedniego labu...
"""

class Rakieta:
    '''Rakieta'''

    def __init__(self, pozycja=(0, 0)):
        self.set_pozycja(pozycja)

    def sprawdz_pozycje(pozycja):
        assert isinstance(pozycja, (tuple, list)), 'pozycja powinna być listą/krotką'
        assert len(pozycja) == 2, 'pozycja powinna mieć 2 elementy'
        assert isinstance(pozycja[0], (int, float)), '1 element pozycji ma być liczbą'
        assert isinstance(pozycja[1], (int, float)), '2 element pozycji ma być liczbą'
        assert pozycja[1] >= 0, 'drugi element pozycji >= 0'

    def get_pozycja(self):
        return self.pozycja

    def set_pozycja(self, nowa_pozycja):
        'ustaw var jako nową wartość pozycji'
        Rakieta.sprawdz_pozycje(nowa_pozycja)  # __class__.sprawdz_pozycje(nowa_pozycja)
        self.pozycja = nowa_pozycja

    def przesun_rakiete(self, przesuniecie):
        x, y = self.get_pozycja()  # czytaj pozycję
        dx, dy = przesuniecie  # czytaj przesuniecie
        nowa_pozycja = (x + dx, y + dy)  # oblicz nowa pozycje
        self.set_pozycja(nowa_pozycja)  # ustaw nową pozycję

    def w_gore(self, gora):
        self.przesun_rakiete((0, gora))

    def w_dol(self, dol):
        self.przesun_rakiete((0, -dol))

    def w_prawo(self, prawo):
        self.przesun_rakiete((prawo, 0))

    def w_lewo(self, lewo):
        self.przesun_rakiete((-lewo, 0))

    def laduj(self):
        x, y = self.get_pozycja()
        self.set_pozycja((x, 0))

    def __repr__(self):
        return f'Rakieta na pozycji {self.get_pozycja()}'

    def __str__(self):
        return self.__repr__()


class RakietaBojowa(Rakieta):
    '''Rakieta Bojowa'''

    def __init__(self, pozycja=(0, 0), moc=0):
        super().__init__(pozycja=pozycja)
        self.set_moc(moc)

    def get_moc(self):
        return self.moc

    def set_moc(self, var):
        'ustaw var jako nowa wartość siły działa laserowego'
        assert isinstance(var, (int, float)), 'moc lasera jako liczba'
        self.moc = var

    def __repr__(self):
        return f'Rakieta Bojowa o mocy {self.get_moc()} na pozycji {self.get_pozycja()}'

r = Rakieta()
r

rb = RakietaBojowa()
rb



"""### Co dwa obiekty to nie jeden, czyli nieco o wzajemnych relacjach `self` i `other`
Jeżeli kiedykolwiek zapytali Państwo interpreter języka Python czy zmienna `x = 2` jest większa od zmiennej `y = 1` to w zasadzie zapytaliście o to, co zwraca pewna funkcja specjalna (`__gt__`), zaprogramowana by porównywać ze sobą liczby. Jak to się dzieje, że klasa wie, co ma ze sobą porównać? Do którego pola/atrybutu ma się odwołać w obu zmiennych?

Takie sprawy załatwia się za pomocą odniesienia do zmiennych określających obiekty, które chcemy np: porównać. Wykorzystamy sobie klasę `Prostokat` jako klase bazową. Nie będę ustawiał setterów i getterów, dla uproszczenia kodu (Państwo wiedzą, że w sumie to *powinienem*)
"""

class InnyProstokat:
    "Obiekt Prostokat opisuje nam wlasnosci prostokatow."

    def __init__(self, a, b):
        self.a = a
        self.b = b

    def pole(self):
        return self.a * self.b

    def obwod(self):
        return 2 * (self.a + self.b)

    def czy_wiekszy_od(self, other):
        return self.pole() > other.pole()

    def __str__(self):
        return f"Prostokat o polu {self.pole()} i obwodzie {self.obwod()}"

class Kwadrat(InnyProstokat):

    def __init__(self, a):
        b = a
        super().__init__(a, b)

    def czy_wiekszy(self, other):
        return self.obwod() > other.obwod()

    def przekatna(self, a):
        return a**(1/2)

    def get_bok(self):
        return self.a

    def sprawdz_bok(a):
        assert isinstance(a, int), 'a musi byc int'
        assert a > 0, 'musi byc wieksze od 0'
        return

    def set_bok(self, var):
        __class__.sprawdz_bok(var)
        self.a = var
        return ""

    def __repr__(self):
        return f"kwadrat jest o boku {self.a}, jego pole to {self.pole()}, a obwod to {self.obwod()}"

    def __str__(self):
        return self.__repr__()


p1 = InnyProstokat(1, 1)
p2 = InnyProstokat(1, 3)
print(p1)
print(p2)

kwadrat1 = Kwadrat(8)
kwadrat2 = Kwadrat(5)

print(kwadrat1.czy_wiekszy_od(kwadrat2))

"""Zapytajmy się teraz czy `p1` jest większy od `p2`.

"""

p1.czy_wiekszy_od(p2)

"""To po kolei. Funkcja `czy_wiekszy_od(self, other)` porównuje wynik, jaki zwracają metody `pole` obiektów `self` oraz `other`.

    def czy_wiekszy_od(self, other):
        return self.pole() > other.pole()
        
Wiemy już, że pod `self` podstawia się nazwa obiektu, do którego należy metoda `czy_wiekszy_od`, czyli u nas `p1`. Jako argument podajemy do funkcji `p2`. Cały ten obiekt zostaje przypisany do parametru formalnego `other`. W tym przykładzie założone jest, że obiekt `other` będzie miał taką metodę jak `pole()`, więc kod wywoła się bez błędu. Możemy spokojnie to założyć, gdy podamy jako argument funkcji `czy_wiekszy_od` obiekt powstały jako instancja tej samej klasy co obiekt przypisany do `self`, dokładnie tak jak w przykładzie powyżej.

> `self` oraz `other` to po raz kolejny **konwencja**, można używać dowolnych dopuszczalnych nazw zmiennych, ale prosze tego nie robić - proszę używać tych dwóch, bo PEP8
"""



"""### Ćwiczenie 2
Proszę dopisać do swojej klasy funkcję porównującą w dwóch instancjach (`self` i `other`) ów drugi atrybut jaki Państwo 
dodali do swoich statków z uniwersum SW, a nastepnie przećwiczyć te relacje.
"""





"""### Duck Typing
Inną ciekawą rzeczą, jest to, że jedyne czego wymagamy w obu funkcjach `czy_wiekszy_od(self, other)` i `__gt__(self, other)` jest to, by dany obiekt miał odpowiednio metody `pole` i `obwod`. Jeżeli znajdziemy inny obiekt, możliwe, że kompletnie innej klasy który będzie taką metodę miał, to spokojnie będzie można porównać oba obiekty! Skupmy się na operatorze większości i odpowiadającej mu funkcji `__gt__`
"""

czworobok = Czworobok(1, 2, 3, 4)
prostokat = ProstokatPlus(3, 4)
prostokat > czworobok

"""ale nie możemy tego samego zapytać 'w drugą stronę', bo klasa `Czworobok` nie posiada definicji funkcji `__gt__`"""

try:
    czworobok > prostokat
except TypeError as e:
    print(e)

"""Operację takiego odwoływania się do pól (atrybutów, metod) obiektów, których nie znamy definicji, ale *spodziewamy się że dana funkcjonalność występuje* nazywamy **duck typing**.

> **Duck typing** – rozpoznawanie typu obiektu nie na podstawie deklaracji, ale przez badanie metod udostępnionych przez obiekt. Technika ta wywodzi się z powiedzenia: „jeśli chodzi jak kaczka i kwacze jak kaczka, to musi być kaczką”. (Za [Wikipedią](https://pl.wikipedia.org/wiki/Duck_typing))

Tutaj rzeczywiście możemy spodziewać się, że wszystkie figury geometryczne płaskie składające się z odcinków będą miały własność związaną z obwodem, oraz, że funkcja będzie nazwyała się (w Polsce) `obwod` lub jakoś podobnie jak z angielska `perimeter` albo na lekcjach przyrody `srednica`.
"""

_c = Czworobok(1, 2, 3, 4)
_p = Prostokat(1, 2)
_k = Kwadrat(1)
_ip = InnyProstokat(1, 2)
_pp = ProstokatPlus(1, 2)

for figura in [_c, _p, _k, _ip]:
    print(_pp > figura)



"""### Polimorfizm, abstrakcja, hermetyzacja

Są to trzy kluczowe słowa, które zawsze usłyszycie gdy ktoś będzie mówił o tym co to klasa, lub przeczytacie czytając o programowaniu zorientowanym obiektowo. Są to też słowa kluczowe o jakie będę pytał na egzaminie (z AiP lub inżynierskim). Podam je tutaj ze sporym wykorzystaniem innych źródeł z moim dodatkowym komentarzem

#### Abstrakcja
Teoretycznie, chodzi o to, by budować obiekty i korzystać z metod bez dokładnej wiedzy jak dana metoda/funkcja działa. Np: wiemy że `kwadrat.pole()` zwróci nam pole powierzchni kwadratu, ale nie musimy wiedzieć, że polega to na podniesieniu do kwadratu długości boku kwadratu. Strasznie się kwadratowo zrobiło...

Technicznie to pewnego rodzaju uogólnienie, przedstawiane najczęściej jako klasa abstrakcyjna, czyli taka, której instacji nie będziemy w stanie albo stworzyć albo z niej skorzystać.
W jP nie mamy w teorii mechanizmu, by budować klasy czysto abstrakcyjne z poziomu *biblioteki standardowej* (czy jeżeli wolicie - czystego interpretera, bez importów).
Możemy troszeczkę taki mechanizm wymusić budując klasy abstrakcyjne, z których nakażemy póżniej dziedziczyć. W klasach takich możemy wymusić istnienie pewnych funkcji i zaprogramować je z wykorzystaniem podnoszenia wyjątków.

> **Uwaga**: `NotImplementedError` oraz `NotImplemented` to kompletnie dwa różne wyjątki
"""

class Figura:
    """Abstrakcyjna klasa do opisu Figur"""

    # wymuszamy implementacje funkcji pole bo
    # w ogolnosci nie wiemy jak obliczyc pole dowolnej figury
    def pole(self):
        raise NotImplementedError("Funkcja pole() nie jest zaimplementowana")

    # wymuszamy implementacje funkcji obwod bo
    # w ogolnosci nie wiemy jak obliczyc obwod dowolnej figury
    def obwod(self):
        raise NotImplementedError("Funkcja obwod() nie jest zaimplementowana")


class Kwadrat(Figura):
    def __init__(self, a):
        self.a = a

k = Kwadrat(13)
try:
    k.pole()
except NotImplementedError as e:
    print(e)

"""Praktycznie wszystkie wzorce projektowe i zasady programowania bazują na abstrakcji. Jeżeli tworzymy zależności w kodzie to chcemy się uzależniać od abstrakcji, a nie od konkretnej implementacji. Usuwając to założenie bardzo ograniczamy sobie możliwości. Abstrakcja jest ważna, dzięki niej możemy zapewnić rozszerzalność naszej aplikacji czy możemy zredukować niepotrzebne zależności.

W rzeczywistości jP ma dostep do infrastuktury programowania abstrakcyjnego za pomocą biblioteki `ABC`. Jeżeli jesteście zainteresowani to odsyłam [do dokumentacji klasy ABC](https://docs.python.org/3/library/abc.html). Na tych zajęciach nie ma na to wszystko zbytnio miejsca.
"""



"""#### Hermetyzacja
Czyli ukrywanie implementacji, enkapsulacja. Zapewnia, że jakiś obiekt nie może zmieniać stanu wewnętrznego innych obiektów w nieoczekiwany sposób. Tylko własne metody obiektu są uprawnione do zmiany jego stanu. Właśnie dlatego programowali Państwo te wszytskie **gettery** i **settery**.

Każdy typ obiektu prezentuje innym obiektom swój interfejs, który określa dopuszczalne metody współpracy. Pewne języki osłabiają to założenie, dopuszczając pewien poziom bezpośredniego dostępu do wszystkich atrybutów obiektu. Język Python dopuszcza nawet dostęp do metod ukrytych. Jest to dość poważna samowolka, ale bazuje na zaufaniu do programistów. Daje to możliwość prostego rozszerzania progamów (bez programowania get/set), co na wczesnych stadiach rozwoju programów może być pożądane - tak jest po prostu szybciej. Z drugiej strony jest źródłem bardzo brzydkiego programowania...

Z hermetyzacją klas wiąże się też odpowiedzialność za stworzenie obiektu niezależnego od świata zewnętrznego. Obiekt powinien być samowystarczalny - hermetyczny. Nie powinien 'wpuszczać' innych obiektów, tak by mogły w nieporządany sposób zmienić jego stan, ale też wymaga bardzo porządnego projektu klasy, tak by nie brakowało niezbędnych funkcji. Proszę sobie wyobrazić klasę `Kwadrat` bez funkcji `pole`. Za każdym razem, gdy potrzebowalibyśmy tego nieszczęsnego pola, trzeba by wykonywać coś w stylu

    kwadrat.get_bok() ** 2



#### Polimorfizm
W dosłownym sensie polimorfizm oznacza zdolność przyjmowania różnych form. W Pythonie polimorfizm pozwala nam definiować metody w klasie potomnej o takich samych nazwach, jakie zostały zdefiniowane w klasie macierzystej.

Jak wiemy, klasa potomna dziedziczy wszystkie metody z klasy macierzystej. Jednak napotkasz sytuacje, w których metoda odziedziczona z klasy nadrzędnej nie pasuje do klasy podrzędnej. W takich przypadkach konieczne będzie ponowne zaimplementowanie metody w klasie potomnej. Ten proces nazywa się zastępowaniem metod.

Jeśli przesłoniłeś metodę w klasie potomnej, wówczas wersja metody zostanie wywołana na podstawie typu obiektu użytego do jej wywołania. Jeśli obiekt klasy podrzędnej jest używany do wywołania metody przesłoniętej, wywoływana jest wersja metody klasy podrzędnej. Z drugiej strony, jeśli obiekt klasy nadrzędnej jest używany do wywołania metody przesłoniętej, wówczas wywoływana jest wersja metody klasy nadrzędnej.

W przypadku jaki podawaliśmy przy abstrakcji, w zasadzie musimy przesłonić funkcje `pole` i `obwod`, bo inaczej będą bezużyteczne...
"""

class Kwadrat(Figura):

    def __init__(self, bok):
        self.bok = bok

    def get_bok(self):
        return self.bok

    def set_bok(self, x):
        assert isinstance(x, (int, float))
        self.bok = x
        return self.get_bok()

    def pole(self):
        return self.get_bok() ** 2

    def obwod(self):
        return self.get_bok() * 4

k = Kwadrat(12)
k.pole()

"""Dziedzicząc dalej, możemy stworzyć klasę `Szescian`, gdzie dziedzicząc po `Kwadracie` musimy znów nadpisać `pole`. Jeżeli uznamy sumę długości krawędzi takiej figury za obwód to należało by i przesłonić `obwod`."""



"""### Ćwiczenie 3
Budujemy hierarchię klas.

#### Ćwiczenie 3.1
Zbuduj klasę `Trojkat`
* 3 boki (set/get)
* `obwod`
* `pole`
* `jest_wiekszy` w oparciu o obwód lub pole - > do wyboru
* lub `__gt__` jeżeli wprowadziliśmy/chcemy wprowadzić ten operator i jemu podobne funkcje specjalne

#### Ćwiczenie 3.2
Dziedzicząc z `Trojkat`, zbuduj `TrojkatRownoramienny`.

#### Ćwiczenie 3.3
Dziedzicząc z `TrojkatRownoramienny`, zbuduj `TrojkatRownoboczny`.
"""

