# -*- coding: utf-8 -*-
"""is_aip_lab04_pzo2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B1HfNVAxbF3Dp9L3QVa9id4qZgRUBfxl

# Algorytmy i programowanie

## Progamowanie zorientowane obiektowo (PZO), część 2 - dziedziczenie

> **Uwaga 1** treść z gwiazdką `*` jest rozszerzeniem
"""



"""Na poprzednim labie omówiliśmy sobie pokrótce jak budować proste klasy definiujące nam obiekty. Zaczeliśmy od klasy `Gruszka`, która reprezentowała nam rzeczywisty obiekt - gruszkę. Zerknijcie poniżej, to ta sama podstawowa klasa, co poprzednio, ale z nieco innym *docsringiem*. Ten jest w stylu [Pydoc](https://docs.python.org/3/library/pydoc.html)/[Sphinx](https://www.sphinx-doc.org/) z użyciem [reStructured Text](http://docutils.sourceforge.net/rst.html). Jest to najbardziej podstawowy/popularny rodaj dokumentacji dla jP, choć nieco mniej czytelny od googlowskiego. Pełny opis możecie znaleźć [na stronie Sphinx](http://www.sphinx-doc.org/en/1.6/domains.html)."""



"""**Jeżeli czytacie ten dokument sami:**
warto zrobić zadanie domowe P04X (`is_aip_pd04.ipynb`). Polecamy teraz - przyda się przy budowaniu dokumentacji do waszych klas.
"""

print("--------------------------------------------")

class Gruszka:

    # docstring::::
    '''
    Obiekt Gruszka opisuje nam wlasnosci gruszek.

    Tutaj powinien byc nieco dluzszy tekst opisujacy klase Gruszka.
    Moze kiedys bedzie to mialo sens, ale na razie nie ma.

    :param odmiana: trzyma odmiane owocu
    :type odmiana: str
    :param waga: trzyma wage gruszek
    :type waga: int, float
    :param str smak: opisuje smak gruszek (slodki, kwasny, itd.)

    :Example:

    # >>> gruszka1 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')
    # >>> gruszka2 = Gruszka('Komisowka', 110, 'slodka')
    # >>> gruszka1.waga
    130
    '''

    def __init__(self, odmiana, waga, smak):
        self.odmiana = odmiana
        self.waga = waga
        self.smak = smak

    def sprawdz_odmiane(odmiana):
        assert isinstance(odmiana, str), 'odmiana musi być stringiem'
        return

    def sprawdz_waga(waga):
        assert isinstance(waga, (float, int)), 'waga musi być liczbą. int or float'
        assert waga > 0, 'waga zawsze dodatnia +'
        return

    def sprawdz_smak(smak):
        assert isinstance(smak, str), 'odmiana musi być stringiem'
        return

    def get_odmian(self):
        return self.odmiana

    def get_waga(self):
        return self.waga

    def get_smak(self):
        return self.smak

    def set_odmiana(self, var):
        __class__.sprawdz_odmiane(var)
        self.odmiana = var
        return ""

    def set_waga(self, var):
        __class__.sprawdz_waga(var)
        self.waga = var
        return ""

    def set_smak(self, var):
        __class__.sprawdz_smak(var)
        self.smak = var
        return ""

    def __repr__(self):
        return f'Gruszka o odmianie {self.get_odmian()} waży {self.get_waga()} i jest smaku {self.get_smak()}'

    def __str__(self):
        return  f'Gruszka o odmianie fdfsdf'


gruszka_1 = Gruszka("biała", 65, "jakiś")
print(gruszka_1.get_odmian())

print(gruszka_1.set_odmiana("polska"))
print(gruszka_1.set_waga(5))
print(gruszka_1.set_smak("słodkiego"))

# gruszka_1
print(gruszka_1)
print(repr(gruszka_1))

print("--------------------------------------------")


"""Tyle tytułem wstepu...

# Dziedziczenie

Ta lekcja będzie o dziedziczeniu. Jak łatwo sobie wyobrazić każdy jest czyimś potomkiem i po swoich przodkach 
otrzymał przynajmniej jakąś pulę genów. Nie ważne ile i jakich, ważne że dostał. Mamy więc coś z przodkami wspólnego. 
Również w PZO dziedziczenie to w zasadzie przekazywanie cech i atrybutów z jednej klasy do innej.

Klasa która przekazuje cechy to **klasa bazowa** (nadrzędna, rodzic...). Klasa która dziedziczy to **klasa potomna** 
(pochodna, podrzędna, dziecko...).

Naturalną klasą bazową dla `Gruszki` będzie `Owoc`. W sumie to można by go opisać podobnymi atrybutami co gruszkę 
oraz jednym dodatkowym bo musimy dodać `rodzaj` owocu.
"""

class Owoc:
    '''
    Obiekt Owoc opisuje nam wlasnosci owocow.

    Owocami jako rodzajem pozywienia okreslane
    są częsci roslin o grubej warstwie miazszu i
    przyjemnym, zwykle slodkim smaku i zapachu.

    :param str rodzaj: rodzaj owocu
    :param str odmiana: trzyma odmiane owocu
    :param num waga: trzyma wage owocu
    :param str smak: opisuje smak owocu (slodki, kwasny, itd.)

    :Example:

    # >>> gruszka = Owoc('gruszka', 'General Leclerc', 130, 'kwaskowato-slodki')
    # >>> jablko = owoc('jablko', 'Ligol', 89, 'chrupiacy, slodki, delikatnie kwaskowaty')
    # >>> hurma = Owoc('hurma', 'Diospyros lotus', 94, 'slodki')
    '''

    def __init__(self, rodzaj, odmiana, waga, smak):
        self.rodzaj = rodzaj
        self.odmiana = odmiana
        self.waga = waga
        self.smak = smak

    def __str__(self):
        ret = f"{self.smak} owoc, {self.rodzaj} "
        ret += f"z klasy {self.__class__.__name__} "
        ret += f"w odmianie {self.odmiana} i wadze {self.waga}"
        return ret

    def __repr__(self):
        return 'instancja klasy ' + self.__class__.__name__

gruszka = Owoc('gruszka', 'General Leclerc', 130, 'kwaskowato-slodki')
print(gruszka)
# gruszka

"""Aby teraz stworzyć klasę `Gruszka`, bazując na klasie `Owoc`, musimy skonkretyzować jeden atrybut - `rodzaj` i ustawić go na `gruszka`

    self.rodzaj <- 'gruszka'
    
Robimy coś podobnego w jednym z przykładów jakie widać w *docstring*u klasy 'Owoc', ale tam pokazujemy jak stworzyć instancję `gruszka` klasy `Owoc`, nie jak stworzyć klasę `Gruszka` bazując na przodku. W przypadku dziedziczenia wystarczy napisać
"""

class Gruszka(Owoc):
    '''
    Obiekt Gruszka opisuje nam wlasnosci gruszek.

    Tutaj powinien byc nieco dluzszy tekst opisujacy klase Gruszka.
    Moze kiedys bedzie to mialo sens, ale na razie nie ma.

    :param odmiana: trzyma odmiane owocu
    :type odmiana: str
    :param waga: trzyma wage gruszek
    :type waga: int, float
    :param str smak: opisuje smak gruszek (slodki, kwasny, itd.)

    :Example:

    # >>> gruszka1 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')
    # >>> gruszka2 = Gruszka('Komisowka', 110, 'slodka')
    # >>> gruszka1.waga
    130
    '''

    def __init__(self, odmiana, waga, smak):
        Owoc.__init__(self, 'gruszka', odmiana, waga, smak)

gruszka1 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')
print(gruszka1)

"""I to tyle. To wszystko co musimy zrobić, by zdefiniować klasę potomną. W sumie to *docstring* zajmuje więcej lini... 
Zamiast precyzować nazwę klasy nadrzędnej możemy użyć funkcji `super()` by odowłać się do klasy nadrzędnej, z jedną drobną 
zmianą - odwołanie do funkcji `__init__` nie może zawierać wskaźnika na instancję (`self`). Zmieniamy więc

    Owoc.__init__(self, 'gruszka', odmiana, waga, smak)
    
na

    super().__init__('gruszka', odmiana, waga, smak)
"""

class Gruszka(Owoc):
    '''...'''
    def __init__(self, odmiana, waga, smak):
        super().__init__('gruszka', odmiana, waga, smak)

gruszka2 = Gruszka('General Leclerc', 130, 'kwaskowato-slodka')
print(gruszka2)

"""Jak widać, nie musimy ponownie definiować żadnych innych funkcji (`__str__` czy `__repr__`), ponieważ je dziedziczymy. 
Musieliśmy jedynie napisać od nowa `__init__`, tak by móc skonkretyzować `rodzaj`.

Dobrym przykładem jest hierarchia klas opisujących konta bankowe w pliku powiązanym z wykładem. Proszę prześledzić te przykłady

    Konto
    ... KontoDebetowe
    ... KontoOszczednosciowe
    
Innym przykładem będzie też hierarchia klas odpowiadających za wyjątki w jP. Tutaj odsyłam do pliku. Tutaj tylko kopia samej hierarchi. 
Proszę odkomentować ostatnią linię w komórce poniżej, by zobaczyć jak rozbudowana jest hierarchia klas wyjątków w jP.
"""


print("konto$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$")


"""
Napisać klasę Konto i dziedziczące z niej klasy KontoDebetowe i KontoOszczędnościowe.
Klasa Konto ma pola imię, nazwisko i stan konta
Klasy dziedziczące mają to samo co Konto i dodatkowo KontoDebetowe ma pole debet a konto oszczednosciowe ma pole liczba_lokat

"""

class Konto:
    '''
    Obiekt Konto opisuje nam konto klienta .

    Konta opisujemy imieniem, nazwiskiem i określamy obecny stan konta.

    :param str imie: imie wlascieniela konta
    :param str nazwisko: nazwisko wlasciciela konta
    :param num stan_konta: obecy stan konta wlascielecla


    :Example:

    # >>> gruszka = Owoc('gruszka', 'General Leclerc', 130, 'kwaskowato-slodki')
    # >>> jablko = owoc('jablko', 'Ligol', 89, 'chrupiacy, slodki, delikatnie kwaskowaty')
    # >>> hurma = Owoc('hurma', 'Diospyros lotus', 94, 'slodki')
    '''

    def __init__(self, imie, nazwisko, stan_konta):
        self.imie = imie
        self.nazwisko = nazwisko
        self.stan_konta = stan_konta

    def __str__(self):
        ret = f"{self.imie} {self.nazwisko} "
        ret += f"z klasy {self.__class__.__name__} "
        ret += f"jest wlascielem konta z obecnym stanem: {self.stan_konta} zł"
        return ret

    def __repr__(self):
        return 'instancja klasy ' + self.__class__.__name__


konto1 = Konto('Piotr', "Nikt", 0000)
print(konto1)


class KontoDebetowe(Konto):
    def __init__(self, imie, nazwisko, stan_konta, debet):
        Konto.__init__(self, imie, nazwisko, stan_konta)
        self.debet = debet

    def __str__(self):
        ret = f"{self.imie} {self.nazwisko} "
        ret += f"z klasy {self.__class__.__name__} "
        ret += f"jest wlascielem konta z obecnym stanem: {self.stan_konta} zł z debetem {self.debet}"
        return ret

    def sprawdz_debet(debet):
        assert isinstance(debet, int), 'debet musi być liczbą ujemną'
        assert debet < 0, 'debet zawsze ujemny --'
        return

    def get_debet(self):
        return self.debet

    def set_debet(self, var):
        __class__.sprawdz_debet(var)
        self.debet = var
        return ""

class KontoDebetoweDlaMlodych(KontoDebetowe):

    def __init__(self, imie, nazwisko, stan_konta, debet, wiek):
        KontoDebetowe.__init__(self, imie, nazwisko, stan_konta, debet)
        self.wiek = wiek

    def __str__(self):
        ret = f"{self.imie} {self.nazwisko} "
        ret += f"z klasy {self.__class__.__name__} "
        ret += f"jest wlascielem konta z obecnym stanem: {self.stan_konta} zł z debetem {self.debet} w wieku {self.wiek}"
        return ret

    def sprawdz_wiek(wiek):
        assert isinstance(wiek, int), 'wiek musi być liczbą dodatnią'
        assert wiek > 0, 'wiek zawsze dodatni +'
        return

    def get_wiek(self):
        return self.wiek

    def set_wiek(self, var):
        __class__.sprawdz_wiek(var)
        self.wiek = var
        return ""

class KontoOszczednosciowe(Konto):
    '''...'''
    def __init__(self, imie, nazwisko, stan_konta, liczba_lokat):
        Konto.__init__(self, imie, nazwisko, stan_konta)
        self.liczba_lokat = liczba_lokat

    def __str__(self):
        ret = f"{self.imie} {self.nazwisko} "
        ret += f"z klasy {self.__class__.__name__} "
        ret += f"jest wlascielem konta z obecnym stanem: {self.stan_konta} zł i ma {self.liczba_lokat} lokaty"
        return ret

    def sprawdz_liczbe_lokat(liczba_lokat):
        assert isinstance(liczba_lokat, int), 'debet musi być liczbą ujemną'
        assert liczba_lokat >= 0, 'liczba lokat >= 0'
        return

    def get_liczbe_lokat(self):
        return self.liczba_lokat

    def set_liczbe_lokat(self, var):
        __class__.sprawdz_liczbe_lokat(var)
        self.liczba_lokat = var
        return ""

konto2 = KontoDebetowe("piotr", "nowy", 233, 9000)
print(konto2)
print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^tutuajjjjjj^^^^^^^^^^^^^^^^^^^")
print(konto2.set_debet(-100))
print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
konto3 = KontoOszczednosciowe("piotr", "nowy", 2000000, 3)
print(konto3)

print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^tutuajjjjjj^^^^^^^^^^^^^^^^^^^")
print(konto3.set_liczbe_lokat(5))
print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")


# drukuje tree dziewdziczenie z klas
def classtree(cls, indent=0):
    """drukuje wszystkie klasy bledow"""
    print("..." * indent, cls.__name__)
    for sub in cls.__subclasses__():
        classtree(sub, indent=indent+1)

classtree(Konto)

print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")

"""**Jeżeli czytacie ten dokument sami:**
warto zrobić zadanie domowe P0401.
"""



"""# Dziedziczenie wielokrotne

Jest to sytuacja, gdy klasa potomna dziedziczy z kilku klas nadrzędnych jednoczesnie. Możemy to wykonać oddzielając przecinkiem klasy nadrzędne przy definicji klasy potomnej

    class KlasaPotomna(Klasa1, Klasa2, Klasa3):
        CIALO KLASY POTOMNEJ
        
Jako przykład podamy tutaj klasę `KontoPremium` z wykładu (patrz wykład). Dziedziczy ona z 2 klas:

    class KontoPremium(KontoDebetowe, KontoOszczednosciowe):
        ...
        
i ukazuje częsty problem występujący w dziedziczeniu wielokrotnym, tzw. **problem diamentu**. Jeżeli
"""

class KontoPremium(KontoOszczednosciowe, KontoDebetowe):
    '''...'''
    def __init__(self, imie, nazwisko, stan_konta, liczba_lokat, debet, imie_dor, nazwisko_dor):
        super().__init__(imie, nazwisko, stan_konta, liczba_lokat)
        self.debet = debet
        self.imie_dor = imie_dor
        self.nazwisko_dor = nazwisko_dor


    def __str__(self):
        ret = f"{self.imie} {self.nazwisko} "
        ret += f"z klasy {self.__class__.__name__} "
        ret += f"jest wlascielem konta z obecnym stanem: {self.stan_konta} zł i ma {self.liczba_lokat} lokaty"
        return ret

    def sprawdz_imie_nazwisko(imie, nazwisko):
        assert isinstance(imie, str), 'imie musi byc stringiem'
        assert isinstance(nazwisko, str), 'nazwisko musi byc stringiem'
        return

    def get_imie_nazwisko(self):
        return self.imie, self.nazwisko

    def set_imie_nazwisko(self, imie_var, nazwisko_var):
        __class__.sprawdz_imie_nazwisko(imie_var, nazwisko_var)
        self.imie = imie_var
        self.nazwisko = nazwisko_var
        return ""

KontoPremium_1 = KontoPremium("Tom", "Other", "100", "2", "-100", "Sara", "John")
print(KontoPremium_1)
print(KontoPremium_1.get_imie_nazwisko())




# _________________START TUTAJ_______________


class Samochod:
    '''
       Obiekt Samochod opisuje nam samochod klienta.

       Samochody opisujemy marka i kolorem.

       :param str marka: marka samochodu
       :param str kolor: kolorw zamochodu

       :method str naprzod: zwraca opis jadacego samochodu -> str
    '''
    def __init__(self, marka, kolor):
        self.marka = marka
        self.kolor = kolor


    def naprzod(self):
        return "Jedzie samochod"

class Okret:
    '''
          Obiekt Samochod opisuje nam samochod klienta.

          Samochody opisujemy marka i kolorem.

          :param str marka: marka samochodu
          :param str kolor: kolorw zamochodu

          :method str naprzod: zwraca opis jadacego samochodu -> str
       '''

    def naprzod(self):
        return "Płynie okręt"


class Amfibia(Okret, Samochod):
    def __init__(self, marka, kolor, numer):
        super().__init__(marka, kolor)
        self.numer = numer

    def __str__(self):
        ret = f"amfibia ma numer {self.numer}, jest koloru {self.kolor}, marki {self.marka}"
        return ret

    def get_numer(self):
        return self.numer

    def sprawdz_numer(numer):
        assert isinstance(numer, int), 'numer musi bys int'
        assert numer > 0, 'liczba lokat >= 0'
        return

    def set_numer(self, numer):
        __class__.sprawdz_numer(numer)
        self.numer = numer
        return ""

Amfibia_1 = Amfibia("Jakas", "czarny", 3232000)
print(Amfibia_1)

print(Amfibia_1.naprzod())

# KontoPremium_1 = KontoPremium("Tom", "Other", "100", "2", "-100", "Sara", "John")
# print(KontoPremium_1)
# print(KontoPremium_1.get_imie_nazwisko())

print(Amfibia.mro())

"""
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!___START TUTAJ___!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

* A = klasa Konto
* B = klasa KontoDebetowe
* C = klasa KontoOszczednosciowe
* D = klasa KontoPremium

![diament](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Diamond_inheritance.svg/160px-Diamond_inheritance.svg.png)

to w sumie nie wiadomo które atrybuty występujące zarówno w `B` i `C` odziedziczy `D` - te z `C` czy z `B`? 
Problem diamentu jest znany od dawna i różne języki radzą sobie z tym różnie. W jP zaimplementowna została [linearyzacja C3](https://en.wikipedia.org/wiki/C3_linearization), co oddane jest w MRO (method resolution order). Taka sytuacja jest już od jP [w wersji 2.3](https://www.python.org/download/releases/2.3/mro/).

Kolejność dziedziczenia danej klasy można prześledzić za pomocą funkcji `mro()` lub właściwości `__mro__`.
"""

print(Gruszka.mro())

"""Lub też dla przykładu z rysunku"""

class A:
    pass
class B(A):
    pass
class C(A):
    pass
class D(B, C):
    pass

# kolejność przeszukiwania atrybutów, metod, funkcji
# D.__mro__

print(A.mro())
print(D.mro())

"""**Jeżeli czytacie ten dokument sami:**
warto zrobić zadanie domowe P0402.
"""



"""# Atrybuty klasy i atrybuty instancji
Atrybuty jakie znajdziemy z każdej klasie możemy podzielić w ogólności na atrybuty klasy i atrybuty instancji. 
Atrybuty klasy to te, które będą określane dla klasy i każdej jej instacji globalnie, a atrybuty instancji okreslamy 
dla każdej instancji osobno. Poniżej przykład z wykładu
"""

class Konto:
    """Konto bankowe."""
    def __init__(self, wlasciciel_konta, bilans=0):
        self.bilans = bilans
        self.wlasciciel = wlasciciel_konta
        try:
            pierwsza_pusta = wlasciciel_konta.rindex(' ')
            self.nazwisko = wlasciciel_konta[pierwsza_pusta+1:]
        except:
            self.nazwisko = wlasciciel_konta

    def __str__(self):
        """Zwraca reprezentacje konta w postaci ciagu znakow"""
        name = self.wlasciciel
        if type(self.wlasciciel) != str:
            name = str(name)
        ret = "Wlasciciel: " + name + ". "
        ret += "Bilans konta: " + str(self.bilans) + "."
        return ret


class KontoDebetowe(Konto):
    """Bankowe konto debetowe."""
    odsetki = 0.5

    def wyplac(self, wartosc):
        """Pomniejsza bilans konta o wartosc. Zwraca nowy bilans."""
        self.bilans -= wartosc
        if self.bilans < 0:
            self.bilans -= self.odsetki
        return self.bilans

    def __str__(self):
        return super().__str__() + " Odsetki konta: " + str(self.odsetki) + "."

"""Najprościej zrozumieć to tak: atrybuty instancji to te poprzedzone `self.`, atrybuty klasy to te bez. Powyżej tylko zmienna (pole) `odsetki` to atrybut klasy. Popatrzmy na przykład"""

k1 = KontoDebetowe("LM", 100)
k2 = KontoDebetowe("PT", 1000)

print("Oryginalna instancja")
print("k1 ->", k1)
print("k2 ->", k2)

KontoDebetowe.odsetki = 0.7
print("Zmienione odsetki")
print("k1 ->", k1)
print("k2 ->", k2)

"""Teraz pojawia się pytanie - jak już mamy te nowe `odsetki`, to kolejna instancja `k3` będzie z nowymi, czy starymi odsetkami?"""

k3 = KontoDebetowe("JD", 2800)
print(k3)

"""Oczywiście - raz zmieniony atrybut klasy będzie zmieniony, bo niby czemu miałby nie być?

Do atrybutów klasy możemy odwołać się z poziomu klasy poprzez `KontoDebetowe.odsetki` jak 2 komórki wyżej, lub też z poziomu instancji jak robimy to w `__str__` w ddefinicji klasy, lub po prostu
"""

print(k3.odsetki)
KontoDebetowe.odsetki = 0.8
print(k3.odsetki)

"""No a co jeżeli będziemy chcieli zmienić atrybut klasy (`odsetki`) z poziomu instancji?"""

k3.odsetki = 0.4
print(k3)

"""Jak widać zmieniły się odsetki dla konta "JD", ale co z pozostałymi kontami?"""

print("k1 ->", k1)
print("k2 ->", k2)

"""Jak widać powyżej, nie zmieniło się nic jeżeli chodzi o odsetki w pozostałych instancjach. Również, jeżeli stworzymy kolejną instancję, to nic to nie zmieni. Co więcej - zmiana atrybutu `odsetki` klasy po raz kolejny zmieni odsetki **tylko** w instancjach, dla których nie zmienialiśmy artrybutu klasy, te zmienione z poziomu instancji pozostaną nieruszone.

"""

k4 = KontoDebetowe("MK", 200000)
print("k4 ->", k4)

KontoDebetowe.odsetki = 0.93
print("k1 ->", k1)
print("k2 ->", k2)
print("k3 ->", k3)
print("k4 ->", k4)



"""**Jeżeli czytacie ten dokument sami:**
warto zrobić zadanie domowe P0403 i PD04X, jeżeli już go nie rozwiązaliście.
"""

